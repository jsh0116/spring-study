## 저장소 분리와 SAGA 패턴

### Monolith System과 통합 저장소
* 기존 모노리스 시스템의 저장소는 통합저장소이다.
* 어플리케이션 모듈은 분리하되, 저장 처리는 모듈 별로 격리하지 않고 다른 모듈에서의 호출을 허용하는 구조였다.
* 업무 규칙 및 흐름 처리를 위해 존재하는 어플리케이션의 코드 라인 수 보다 SQL의 코드 라인 수가 몇 배 이상이다.
* 위와 같은 구조를 `데이터 중심 어플리케이션`이라 한다.

### 저장소 분리 패턴
* 데이터 중심 어플리케이션을 해결하기 위한 패턴
* 각각의 마이크로서비스는 각자의 비즈니스 처리를 위한 데이터를 직접 소유해야 한다는 것을 의미한다.
* 자신이 소유한 데이터는 다른 서비스에 직접 호출되지 않게 하고 자신이 공개한 API를 통해서만 접근할 수 있다. (정보 은닉)
* 궁극적으로 이러한 제약이 데이터를 통한 변경의 파급효과(영향도)를 줄여 서비스가 독립적이게 된다.
* 마이크로서비스 별 기능 분리와 저장소 격리에 따른 문제가 발생한다.
  * `여러 개의 분산된 서비스를 걸쳐 비지니스 처리를 해야 하는 경우 비지니스 정합성 및 데이터 일관성을 어떻게 보장할 것인가에 대한 문제이다.`
![image](https://user-images.githubusercontent.com/62865808/175525902-9fee9ad0-992e-49e9-ab02-715b64f38211.png)
SK(주) C&C's TECH BLOG - 67 page

### 분산 트랜잭션 처리 패턴
* 여러 서비스 간의 비즈니스 및 데이터 일관성을 유지할 필요가 있다는 의미이다.
* 가장 쉬운 방법은 여러 개의 분산된 서비스를 하나의 일관된 트랜잭션으로 묶는 것이다.
* 2PC(two-phase commit) 기법
  * 분산 데이터베이스 환경에서 원자성(Atomicity)을 보장하기 위해 분산 트랜잭션에 포함되어 있는 모든 노드가 Commit되거나 Rollback하는 메커니즘이다.
  * 각각 서비스에 동시에 락인(lock in)을 걸게 되면 발생하는 퍼포먼스의 문제가 발생하므로 효율적인 방법은 아니다.
  * 각각의 서비스가 다른 인스턴스로 로딩되기 때문에 통제하기 어렵다.
  * 서비스 각각의 저장소가 다를 경우에 문제가 되며 특히 몽고DB같은 No SQL저장소는 2PC 자체를 지원하지 않는다.
  * 클라우드의 가장 큰 장애는 네트워크 장애인 경우가 많은데 이런 네트워크 장애 등으로 특정 서비스의 트랜잭션 처리가 안 될 경우 묶인 서비스가 즉시 영향을 받기도 한다.
  * `독립적이지 않고 비자율적이다'

#### SAGA 패턴
* 여러 개의 분산된 서비스들을 하나의 트랜잭션을 묶지않고 각 로컬트랜잭션과 보상 트랜잭션을 이용하여 비즈니스 및 데이터 정합성을 맞춘다.
* 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴이다.
* 각 로컬 트랜잭션은 자신의 데이터베이스를 업데이트한 다음에 Saga 내에 있는 다음 로컬 트랜잭션을 트리거 하는 메시지 또는 이벤트를 게시하여 데이터의 일관성을 맞춘다.
* 다른 트랜잭션의 결과에 따라 롤백이 필요한 경우
  * `보상 트랜잭션` : 어떤 서비스에서 트랜잭션 처리에 실패할 경우, 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션이다.
  ![image](https://user-images.githubusercontent.com/62865808/175527212-3e408bb7-4824-4e7b-882f-4a46284b0a3d.png)
SK(주) C&C's TECH BLOG - 68 page

> **SAGA 정리**<br />
> 일관성 유지가 필요한 트랜잭션을 모두 묶어 하나의 트랜잭션으로 처리하지 않고, 각각의 로컬 트랜잭션으로 분리하여 순차적으로 처리하는 방법이다.<br />
> 트랜잭션이 실패한 경우 이전 로컬 트랜잭션이 작성한 변경 사항을 취소하는 일련의 보상 트랜잭션을 통해 전체의 일관성을 유지한다.

![image](https://user-images.githubusercontent.com/62865808/175527555-3fa3b4da-c586-4bb2-a452-f7755094de3c.png)
SK(주) C&C's TECH BLOG - 69 page

  * 주문서비스 & 고객서비스
  * 주문 처리 시 고객의 신용한도 정보에 따라 최종 주문을 승인하는 업무
  * 두 서비스의 트랜잭션을 하나로 묶지 않고 보상 트랜잭션과 이벤트를 활용해서 처리할 수 있다.
  1. 주문 처리가 시작되면 주문 서비스는 가주문을 생성하며, 주문자정보가 담긴 ‘가주문이 생성됨’ 이벤트를 발행하고 트랜잭션을 종료한다.
  2. 고객서비스가 ‘주문 생성됨’ 이벤트를 확인한 뒤 다음 처리를 수행한다.<br />
    a. 이벤트에 존재하는 주문자 정보로 고객의 신용한도를 조회하여 신용한도가 충족된다면 ‘신용 승인됨’ 이벤트를 발행한다.<br />
    b. 신용한도가 충족되지 않는다면 ‘신용한도 초과됨’ 이벤트를 발행한다.<br />
  3. 주문 서비스는 고객 서비스가 발행한 이벤트를 확인한다.<br />
    a. 고객서비스가 발행한 이벤트가 ‘신용 승인됨’인 경우에는 주문 승인 처리를 한다.<br />
    b. ‘신용한도 초과됨’ 이벤트인 경우에는 보상트랜잭션인 주문 처리 취소를 수행한다.<br />

**이와 같이 하나의 큰 트랜잭션으로 묶지 않고 4개의 분리된 로컬 트랜잭션으로 비지니스의 정합성을 맞출 수 있다.**

[데이터 일관성 → 결과적 일관성](https://engineering-skcc.github.io/microservice%20outer%20achitecture/inner-architecture-saga/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81%EC%9D%98-%EC%A0%84%ED%99%98-%EA%B2%B0%EA%B3%BC%EC%A0%81-%EC%9D%BC%EA%B4%80%EC%84%B1)
  
