## Message Queue

### 메시지 큐(Message Queue, MQ)
* 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법이다.
* 메시지 지향 미들웨어 (Message Oriented Middleware, MOM)
  * 비동기 메시지를 사용하는 프로그램 간의 데이터 송수신이다.
  * MOM을 구현한 시스템을 MQ라고 한다.

#### 특징
* 비동기 - Queue에 넣기 때문에 즉시 처리할 필요 없이 나중에 처리할 수 있다.
* 비동조- Application과 분리할 수 있다.
* 탄력성 - 일부가 실패하더라도 전체는 영향을 받지 않는다.
* 과잉 - 실패할 경우 재실행이 가능하다.
* 확장성 - 다수의 프로세스들이 큐에 메시지를 보낼 수 있다.

#### 장점
* 애플리케이션 & 시스템 간의 통신
  * 서버 간의 데이터를 주고 받거나 어떤 작업을 요청할 때 항상 시스템 장애를 염두해야 한다.
  * 서버가 갑자기 죽거나 서버 점검 등으로 다운 타임이 발생하는 동안에는 요청을 보낼 수 없다.
  * 서버가 아니라 MQ에 요청을 전달하며, MQ로부터 요청 데이터를 수신해서 처리한다.
  * 만약 서버에서 요청을 받을 수 없는 상황이라면 해당 요청은 MQ에 머무르고 있다가 수신이 가능할 때 서버에 전달된다.
  * MQ에 다운타임이 발생할 경우 문제가 발생하지만 그에 따른 고가용성을 위해 클러스터링 등을 지원한다.
* 서버 부하가 큰 작업
  * 이미지 처리, 비디오 인코딩, 대용량 데이터 처리들 같은 경우에는 메모리와 CPU를 많이 사용하게 된다.
  * 동시에 처리할 수 있는 데이터의 양이 한정적이다.
  * 처리할 작업을 MQ에 넣어두고 서버는 자신이 동시에 처리할 수 있는 양에 따라 MQ에서 하나씩 작업을 가져와 처리한다.
* 부하 분산
  * 여러 대의 서버가 하나의 큐를 바라보도록 구성하면 처리할 데이터가 많아져도 각 서버는 자신의 처리량에 맞게 MQ에서 가져와 처리할 수 있다.
* 데이터 손실 방지
  * 외부에서 받은 요청을 메모리에 저장했다가 들어온 순서대로 처리하는 경우가 있다.
  * 메모리에 저장했을 때 서버가 다운되면 메모리에 쌓아둔 요청은 모두 없어진다.
  * MQ에 들어온 태스크가 일정 시간이 지나도록 처리되지 않으면 MQ는 해당 태스크를 다시 큐에 넣어 나중에 처리할 수 있도록 한다.

#### 주의사항
* MQ는 많은 장점들을 가지고 있지만 상황에 맞게 사용해야 한다.
* **요청 결과를 즉시 응답해야하는 경우에 MQ는 적합하지 않다.**
* 요청과 별개로 처리할 수 있는 비동기 처리에 적합하다.
* 서버에서 간단하게 처리할 수 있는 일을 MQ를 통해 전달하면 불필요한 오버헤드가 발생할 수 있다.

### MQ의 공통 특징
1. 다른 곳의 API로부터 데이터 송수신한다.
2. 다양한 Application에서 비동기 통신이 가능하다.
3. 이메일 발송 및 문서 업로드를 할 수 있다.
4. 많은 양의 프로세스를 처리한다.

#### 종류
1. Kafka
    * 확장성과 고성능 및 높은 처리량이 특징이다.
    * 처리량이 많은 분산 메시징 시스템에 적합하다.
    * 분산 시스템을 기본으로 설계되어 기존 메시징 시스템에 비해 분산 및 복제 구성을 손쉽게 할 수 있다.
    * 장점
      * 대용량 실시간 로그 처리에 특화되어 있다.
      * AMQP Protocol이나 JSM API를 사용하지 않고 단순한 메시지 헤더를 지닌 TCP 기반 Protocol 사용함으로써 오버헤드가 비교적 작다.
      * 노드 장애에 대한 대응성을 가지고 있다.
      * 프로듀서는 각 메시지를 배치로 브로커에게 전달하여 TCP/IP 라운드 트립을 줄였다.
      * 메시지를 기본적으로 파일 시스템에 저장하여 별도의 설정을 하지 않아도 오류 발생 시 오류 지점부터 복구가 가능하다.
        * 기존 메시징 시스템은 메시지를 메모리에 저장했다.
      * 메시지를 파일시스템에 저장하기 때문에 메시지가 많이 쌓여도 기존 메시징 시스템에 비해 성능이 크게 감소하지 않는다.
      * window 단위의 데이터를 넣고 꺼낼 수 있다.

2. [RabbitMQ](https://rabbitmq.com/)
    * 신뢰성 있는 메시지 브로커가 필요한 경우에 적합하다.
    * AMQT 프로토콜을 구현한 프로그램으로써 빠르고 쉽게 구성할 수 있으며, 직관적이다
    * 장점
      * 신뢰성과 안정성이 높다.
      * 유연한 라우팅이 가능하다.
        * Message Queue가 도착하기 전에 라우팅되며 플러그인을 통해 더 복잡한 라우팅도 가능하다.
      * 클러스터링을 할 수 있다.
        * 로컬네트워크에 있는 여러 RabbitMQ 서버를 논리적으로 클러스터링할 수 있고 논리적인 브로커도 가능하다.
      * 관리 UI의 편리성이 높다.
        * 관리자 페이지 및 모니터링 페이지가 제공된다.
      * 거의 모든 언어 및 운영체제를 지원한다.
      * 오픈소스로 상업적 지원이 가능하다.
 
3. ActiveMQ
    * 자바로 만든 오픈소스 메시지 브로커이다.
    * 신뢰성 있는 메시지 브로커가 필요한 경우에 적합하다.
    * JMS 1.1을 통해 자바와 다른 언어를 사용하는 클라이언트를 지원한다.
    * 장점
        * 다양한 언어와 프로토콜 지원한다
          * Java, C, C++, C#, Ruby, Perl, Python, PHP 클라이언트를 지원한다.
        * OpenWire를 통해 고성능의 Java, C, C++, C# 클라이언트를 지원한다.
        * 다른 인기있는 메시지 브로커들과 마찬가지로 Stomp를 통해 C, Ruby, Perl, Python, PHP 클라이언트가 ActiveMQ에 접근 가능하다.
        * Message Groups, Virtual Destinations, Wildcards와 Composite Destination를 지원한다.
        * Spring 지원으로 ActiveMQ는 Spring Application에 매우 쉽게 임베딩될 수 있으며, Spring의 XML 설정 메커니즘에 의해 쉽게 설정 가능하다.
        * Geronimo, JBoss 4, GlassFish, WebLogic과 같은 인기있는 J2EE 서버들과 함께 테스트된다.
        * 고성능의 저널을 사용할 때에 JDBC를 사용하여 매우 빠른 Persistence를 지원한다.
        * REST API를 통해 웹기반 메시징 API를 지원한다.
        * 웹 브라우저가 메시징 도구가 될 수 있도록 Ajax를 통해 순수한 DHTML을 사용한 웹 스트리밍을 지원한다.

#### Reference
[Kafka란?](https://velog.io/@qlgks1/0%EC%9E%A5.-%EC%B9%B4%ED%94%84%EC%B9%B4Kafka%EB%9E%80)

[Message Queue란?](https://steady-snail.tistory.com/165)
