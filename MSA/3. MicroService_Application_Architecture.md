# Microservice Application Architecture

> [로버트 C. 마틴 - 클린 아키텍처(인사이트, 2019)](https://blog.insightbook.co.kr/2019/08/08/%ed%81%b4%eb%a6%b0-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98/)
> 코드와 설계의 구조를 깔끔하게 만들려는 생각을 하지 않고 기능 구현에만 목적을 가지면 소프트웨어가 엉망이 된 상황에 대처하는 데에 더 많은 비용이 든다.

#### 기능 구현에만 목적을 두었을 떄의 문제점
* 새로운 형태의 UI나 기술을 추가해야 할 때 새로운 시스템은 만드는 것과 같은 수준으로 수정해야 한다.
* 사소한 기능 변경에도 변경의 파급효과 및 영향도를 알 수 없어 실제 변경 작업보다 다른 모듈의 영향도를 파악하기 위한 테스트에 더 많은 시간을 투자해야 한다.
* 개발과 운영을 모두 책임지고 있는 Microservice팀 입장에서는 초기 개발만이 아닌 지속적인 비즈니스 변화에 빠르게 대응할 수 있는 구조가 필요한데 기민하게 대응하기 어렵다.

## 비즈니스 로직 - 관심사의 분리

### 비즈니스 로직
* 시스템의 목적인 비즈니스 영역의 업무 규칙(Role), 흐름(Flow), 개념(Concept)을 표현하는 용어
* 개발자의 역할은
    * 문제 영역의 비즈니스 로직을 분석 및 이해하고,
    * 프로그래밍 언어로 기능이 잘 동작하면서,
    * 이해하기 쉬우며,
    * 변경하기 쉬운 시스템을 만드는 것이다.

### 설계 원칙 중 관심사의 분리
* 관심 (소프트웨어의 기능이나 목적을 의미)
    * 관심을 분리한다는 것은 각 관심과 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 영향을 덜 받게 하는 것이다.
    * 설계 패턴의 대부분은 이러한 관심의 분리를 실현하는 것을 목적으로 삼는다.
* 시스템의 각 영역이 처리하는 관심사가 분리되어 잘 관리되어야 한다는 의미이다.
* 시스템을 쉽게 이해하고 변경할 수 있게 해준다.
* 각 영역은 관심사에 의해 분리되고 집중되어야 한다.
* 모듈화 및 계층화도 관심사의 분리 원칙에 기인한다.
* 비즈니스 로직 영역(비즈니스 표현)과 기술 영역(기술 문제 처리)은 철저히 분리하는 것이 좋다.
* 비즈니스 로직이 기술보다는 오랫동안 지속되고 안정적이어야 할 애플리케이션의 핵심 영역이기에 기술에 영향을 적게 받도록 설계하는 것을 강조한 데서 기인한다.
* 기술과 비즈니스 로직을 분리했을 때 복잡성이 낮아지고 유지보수성이 높아진다.
* 객체지향 분석설계(OOAD: Object Oriented Analysis and Design)에서는 비즈니스 로직을 누가봐도 이해하기 쉽게 구조화하는 객체 모델로 표현하는 것을 강조해 왔다.

#### 실제적으로 비즈니스 객체 모델이 적용되지 않는 부분
* 관심사의 분리 원칙이나 비즈니스 로직을 표현하는 객체 모델 없이 모든 업무 로직이 데이터 질의 구문인 SQL 문에 들어있는 경우
* 특정 벤더의 데이터베이스에 정통하고 모든 로직을 압축해서 하나의 SQL에 작성한다.
* 코드의 가독성보단 쿼리 성능만을 위한 SQL 문의 최적화에 우선순위를 둔다.
* **문제점**
    * 해당 작성자의 부재 시 소스코드를 이해할 수 없어 변경이 불가능하다.
    * 한 사람에게 의존된 코드이기에 팀의 업무 병목지점이 되고 데이터베이스의 병목지점이 된다.
    * 결국 더는 변경하기 힘들어져 전면적으로 다시 개발할 수밖에 없다.
* 애플리케이션의 유지보수성이 높다는 의미는 특정 개인에 의존하기보다는 어느 누구라도 쉽게 이해하고 유지보수할 수 있음을 의미한다.

### 데이터베이스 중심 아키텍처의 문제점
* 데이터 중심의 서비스 내부 구조 구현 방식 (데이터베이스 중심 아키텍처)
    * 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한다.
    * 물리 테이블 모델을 중심에 두고 애플리케이션을 구현하기 위한 사고를 하는 방식이다.
* Spring Framework
    * Controller
    * Service
    * DB I/O
    * DTO
    * 데이터 처리
        * MyBatis(SQL Mapping Framework)
        * ORM
* 서비스에 존재하게 될 로직은 흐름 제어 로직 밖에 없다.
* DTO는 질의를 통해 가져오는 정보 묶음의 역할밖에 할 수 없다.
* 애플리케이션 로직 구성 패턴 중 하나인 트랜잭션 스크립트 구조와 비슷하다.
* 간단한 처리 로직의 경우엔 편하지만 업무가 복잡해지면 점점 복잡성을 제어할 수 없게 된다는 단점이 존재하게 된다.
* 업무 개념이 특정 기술인 관계형 데이터베이스 테이블로 표현되고 업무가 복잡해질수록 업무 규칙이 데이터 질의 언어인 SQL과 섞여 표현된다.
* 비즈니스 민첩성을 위해 유연성과 확장성이 중요하다.
* **문제점**
    * 비즈니스 특정 기능을 위해 읽기에 최적화된 NoSQL 저장소로 교체하기로 결정하더라도 저장소 변경이 쉽지 않다.
    * 저장 기술과 비즈니스 로직이 끈끈하게 붙어 있기 때문에 저장소를 변경했을 때 모든 것을 다시 구현해야 한다.
* 데이터베이스 중심 아키텍처의 성능 측면은 대부분의 성능을 데이터베이스에 의존한다.
* 서비스의 비즈니스 개념과 규칙이 대부분 데이터베이스에 표현되기 때문에 애플리케이션에선 할 일이 적어진다.

> 이전처럼 웹과 관계형 데이터베이스만 고려해야 하는 상황이 아닌 웹, 모바일, 명령형 인터페이스(CLI), IoT 기기 등 여러 디바이스의 입출력을 지원해야 하고
관계형 데이터베이스, 메모리 데이터베이스, NoSQL, 메시지 큐까지 다양한 저장소와의 연계가 필요하다.
> ⇒ 비즈니스 로직 처리와 데이터 처리를 철저히 분리하는 것이 반드시 필요하다.

## Architecture

### Layered Arcbitecture (계층형 아키텍처)
> `Layer`: 물리적인 티어의 개념과 달리 논리적인 개념<br/>
> `Tier`는 물리적인 장비나 서버 컴퓨터 등의 물리층을 의미하는 반면, `Layer`는 티어 내부의 논리적인 분할을 의미한다.

![image](https://user-images.githubusercontent.com/62865808/171831857-fa4ca9be-b05c-4d58-bad4-fc01a18e2999.png)

SK(주) C&C's TECH BLOG - 91 page
> 앨리스케어 콕번이 제시한 아키텍처로, 포트 앤드 어댑터 아키텍처(ports and adapters architecture)라고도 한다.
    
  * Layered Arcbitecture에 DIP를 적용해도 한계가 있다.
  * 문제점
      * Presentation Layer와 Data Access Layer를 보통 Low-level Layer으로 정의하는데, 현대에는 이 두 계층 외에도 다양한 Interface를 필요로 한다.
      * 애플리케이션을 호출하는 다양한 시스템의 유형 및 애플리케이션과 상호작용하는 다양한 저장소가 존재한다.
      * 단방향 계층구조에서는 이러한 점을 지원하기 힘들다.
      * 이러한 문제점을 해결하기 위한 방법이 **Hexagonal Architecture(헥사고날 아키텍처)**다.
  > Hexagonal Architecture는 고수준의 비즈니스 로직을 표현하는 내부 영역과 Interface 처리를 담당하는 저수준의 외부 영역으로 나뉜다.
  * 내부 영역
      * 순수한 비즈니스 로직을 표현하는 기술 독립적인 영역
      * 외부 영역과 연계되는 포트
  * 외부 영역
      * 외부에서 들어오는 요청을 처리하는 `인바운드 어댑터`
          * REST API를 발행하는 Controller
          * Web Page를 구성하는 Spring MVC Controller
          * Command Handler
          * Event Message Subscribe Handler
      * 비즈니스 로직에 의해 호출되는 외부와 연계되는 아웃바운드 어댑터
          * 데이터 액세스 처리 담당 DAO
          * 이벤트 메시지 발행하는 클래스
          * 외부 서비스를 호출하는 프락시
  * 특징
      * 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게 한다.
      * 이와 같은 의존성 제거는 내부 영역에 구성되는 포트 덕분에 가능해진다.
  * 인바운드 포트
      * 내부 영역의 사용을 위해 표출된 API이며, 외부 영역의 인바운드 어댑터가 호출한다.
  * 아웃바운드 포트
      * 내부 영역이 외부를 호출하는 방법을 정의한다.
      * 아웃바운드 어댑터가 아웃바운드 포트에 의존해서 구현한다.





