# MicroService (마이크로서비스)

참고 : [마이크로서비스 정의 - 마틴 파울러](https://martinfowler.com/articles/microservices.html)

## Monolith와 MicroService 비교
---
### Monolith
---
> 전통적인 시스템 구조 <br/>
> 하나의 단위로 개발되는 일체식 Application <br/>
> 'Client - 전체 System - DB' 형식 <br/>

* Server 측 Application이 하나에 개발되므로 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포가 필요하기 때문에 특정 기능만 확장할 수 없으며, 반드시 전체 애플리케이션을 동시에 확장해야 한다.
* Service가 점차 성장하고 발전하며 그에 상응하는 요구사항으로 인해 서비스는 점차 복잡해질 수 있다.
  * `새로운 기능들도 생기고, 기존에 있던 기능들도 커지기 때문이다.`
* 보통 Load Balancer를 앞에 두고 여러 instance 위에 큰 덩어리를 복제해 수평으로 확장한다.

#### Monolith의 단점
* 빌드 시간 및 테스트 시간이 길어진다.
  * 여러 개의 Monolith System 전체를 build & 배포해야 한다.
* 개발 언어에 종속적이다.
* 선택적으로 확장할 수 없다.
* 하나의 서비스가 다른 모든 서비스에 영향을 준다.
* DB에서 장애가 일어날 시 탄력적으로 대응할 수 없다.
  * Application의 경우에는 병렬로 되어 있다보니 확장을 하더라도 사용량 증가에 대응할 수 있지만 DB는 보통 1개로 되어있다보니 대응이 어려운 경우가 많다.

### MicroService
---
* Server 측이 여러 개의 조각으로 구성돼 각 Service가 별개의 instance로 로딩된다.
  * 여러 Service instance가 모여 하나의 Business Application을 구성한다.
* 각기 다른 저장소로 업무 단위로 모듈 경계가 명확하게 구분된다.
* 확장 시에는 특정 기능별로 독립적으로 확장할 수 있고, 특정 Service를 변경할 필요가 있다면 해당 Service만 build해서 배포하면 된다.
* 각 Service가 독립적이어서 서로 다른 언어로 개발하는 것도 가능하므로 각 Service의 소유권을 분리해 서로 다른 팀이 개발 및 운영할 수 있다.
* 각 Service가 분리되어 별도의 DB를 가지고 있으며, 특정 Service의 확장이 필요할 경우 해당 Service만 scale out하면 된다.

#### MicroService의 단점
* 성능 이슈
  * 서로 독립적인 Service로 분리된 Component들은 API 통신을 통해 데이터를 주고 받아야 하기 때문에 성능 저하가 발생할 수 있다.
* Transaction 관리의 어려움
  * 서로 독립적인 Service로 분리된 Component들 간의 발생한 transaction을 관리하기 어렵다.
* Data 무결성 보장의 어려움
  * Service 단위로 분리된 Data Layer 간의 DeNormalization(역정규화)를 하게 될 경우, Data Integrity(데이터 무결성)을 보장하기 어렵다.
* System의 복잡도가 높고 높은 기술력을 요구한다.

## SOA와 MicroService
---
### 소프트웨어 공학에서의 모듈화(modularity) 개념 발전 흐름
---
* 구조적 방법론 : 단순히 기능을 하향식 분해해서 설계해 나가는 방법
* 객체지향적 방법론 : 객체 단위로 모듈화하기 위한 방법
* CBD (Component Based Development) : 모듈화의 단위가 기능별로 재사용할 수 있는 좀 더 큰 Component가 되는 방법
* SOA (Service Oriented Architecture) : Component를 모아 Business적으로 의미 있고 완결적인 Service 단위로 모듈화하는 방법

`넓게 보면 CBD & SOA는 단위 Component나 Service를 구성해서 System을 만드는 개념이며, MicroService System의 구조와 매우 유사하다.`

#### MSA (MicroService Architecture)
> MicroService 기반으로 시스템을 개발하는 Architecture 및 개발 방식

### Service 기반 Architecture를 칭하는 SOA와 MSA 개념적 차이점
* 여러 개의 응집된 Business Service의 집합으로 System을 개발한다는 점에서는 SOA와 MSA는 개념적으로 큰 차이가 없다.
* SOA는 구체적이지 않고 이론적이며, 실제 Business 성공 사례가 많지 않다.
* MSA는 Cloud Infra 기술의 발전과 접목되어 Amazon과 Netflix에 의해 구체화되고 Business 성공 사례가 존재한다.

`이상적이었지만 성공을 증명 못한 SOA ⇒ 클라우드 인프라 등장으로 Hardware를 유연하게 다룰 수 있게 되며 실현되어 성공적으로 증명된 시스템 구조 MSA`

#### 마틴 파울러 - 성공 사례의 특징을 뽑아 MicroService 정의
> MicroService는 여러 개의 작은 서비스 집합으로 개발하는 접근 방법이다.<br/>
> 각 Service는 개별 Process에서 실행되고, HTTP 자원 API 같은 가벼운 수단을 사용해서 통신한다.<br/>
> 또한 Service는 Business 기능 단위로 구성되고, 자동화된 배포 방식을 이용하여 독립적으로 배포된다.<br/>
> Service에 대한 중앙 집중적인 관리는 최소화하고, 각 Service는 서로 다른 언어와 데이터, 저장 기술을 사용할 수 있다.

![image](https://user-images.githubusercontent.com/62865808/166147488-fce29c55-d9f4-4aa1-82ce-db52dead4fa0.png)

* 각 Service와 저장소는 다른 Service 및 저장소와 격리돼 있으며, API를 통해서만 느슨하게 연결된다.
* 독립적으로 확장 가능하며, 하나의 Service만 독립적으로 배포 가능하다.
* 다른 Service와 연계된 API에 영향을 주지 않는다면 내부의 언어나 저장소는 자율적으로 선택할 수 있다.
* 특정 Service를 구축하는데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 `폴리글랏(Polyglot)하다` 라고 표현하며 클라우드 등의 가상 인프라가 지닌 유연성이 이를 가능하도록 지원한다.

#### MSA와 SOA 차이점 및 모듈화 극대화 특징들
* CBD/SOA의 접근법에서는 Application은 모듈별로 분리했으나 데이터 저장소까지는 분리하지 못했다.
 * 여러 Application이 하나의 저장소를 공유한다.
* 데이터의 강한 결합으로 Application도 독립적으로 사용하기가 힘들었다.
* MSA는 두가지 개념으로 모듈화 방식을 강화했고 실현할 수 있게 됐다.
* Service별 저장소를 분리해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화한다.
* 다른 Service의 저장소에 접근하는 수단은 API밖에 없다.
* REST API 같은 가벼운 개방형 표준을 사용해 각 Service가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다.

## MicroService 조건

### 1. 조직의 변화: 업무 기능 중심의 팀

`콘웨이 법칙`: 멜빈 콘웨이가 정의한 조직과 조직이 개발한 소프트웨어의 관계를 정의한 법칙


#### 기존 팀 구성의 문제점
* UI팀, 서버 개발팀, DB팀과 같은 기술별로 팀이 나눠지고, 하나의 애플리케이션을 만드는데 **세 팀간의 의사소통**이 필요하다.
* 팀 간 의사결정이 느리며, 의사소통이 어렵다

#### 업무 기능 중심 팀
`다기능 팀 (Cross-Functional Team)`: 여러 기능들이 모여 있다는 의미
* 역할 또는 기술 별로 팀이 분리되는 것이 아닌, 업무 기능을 중심으로 기술이 **다양한 사람이 하나의 팀이 되어 서비스를 만드는 것**을 의미한다.
* 다양한 역할(기획자, 디자이너, 프론트엔드 개발자, 벡엔드 개발자, 설계자, 테스터 등)으로 구성되고, 이 팀은 서비스를 처음부터 끝까지 만들기 위한 모든 단계의 역할을 모두 갖추고 있다.
* 같은 공간, 같은 시간을 공유하기 때문에 의사소통도 원활하고 의사 결정도 빠르게 진행될 수 있다.
* 이 팀은 자율적으로 담당 비즈니스에 관련된 서비스 개발 뿐만 아닌 개발 이후 운영할 책임까지 진다.
* 필요한 기능과 기술을 팀 내부에서 모두 해결이 가능하기 때문에 다른 마이크로서비스팀과는 협력할 일이 적을 수 밖에 없다.
  * 다른 팀이 만든 마이크로서비스와 느슨하게 연계(loosely Coupled)된다.

### 2. 관리 체계의 변화: 자율적인 분권 governance, polyglot
> 다기능 팀이 개발과 운영을 책임진다.
* 마이크로서비스를 만드는 조직은 중앙의 강력한 governance를 추구하지 않는다.
* 중앙의 강력한 표준이나 절차 준수를 강요하지 않는다.
* 빠르게 서비스를 만드는 것을 최우선 목적으로 두고, 스스로 효율적인 방법론과 도구, 기술을 찾아 적용한다.

#### Polyglot Programming && Polyglot store
* 각 MicroService 팀은 자신의 Service 성격에 맞는 최적의 언어와 저장소를 자율적으로 선택한다.

### 3. 개발 생명주기의 변화: 프로젝트 -> 제품 중심
#### 기존 개발 생명주기
* 대부분의 애플리케이션 개발 모델이 프로젝트 단위이다.
* 필요한 기술을 사용하는 인력들이 한시적으로 모여 장기간의 프로젝트를 통해 개발을 완료하고 나면 운영 조직에 넘기는 방식으로 진행된다.
 * 개발 조직과 운영 조직이 분리되어 있다.
* 초기에 모든 일정을 계획한다.
 * 요구사항 정의를 통해 개발할 기능을 나열한다.
 * 정의한 요구사항을 토대로 설계를 진행한다.
 * 설계가 완료되면 개발이 진행이 되고, 각 단계를 데드라인 내에 완료함으로써 최종 기능을 제공한다.
 * 프로젝트 기간 중에 발생한 변수나 새로운 아이디어를 포용하지 못한다.

#### MicroService팀의 개발 생명주기
* 비즈니스의 **갑작스런 트렌드 변화에 유연하게 대처해야 하고, 개발뿐만 아니라 운영을 포함한 소프트웨어의 전체 생명주기를 책임져야 한다.**
* 소프트웨어를 완성해야 할 기능들의 집합으로 보는 것이 아닌, **비즈니스를 제공하는 제품**으로 바라보고, **개발한 뒤에 반응을 보고 개선하는 방식으로 개발을 진행**한다.
* 개발 방식 측면에서 프로젝트 형태의 `폭포수 모델 또는 빅뱅` 방식의 진행이 아닌, 점진 반복적인 모델 제품 중심의 `애자일(agile)` 개발 방식을 채용한다.
* 2~3주 단위의 스프린트를 통해 개발 및 배포해서 피드백을 받아 애플리케이션에 반영한다.
* 한시적 프로젝트 통해 고객의 고정된 요건을 받아 기능이 만족되면 제공하며 개념을 전달한다.
 * 요건의 변화에 따라 **지속적으로 개선되고 발전시킬 제품으로 바라본다.**
* 지속적으로 변화 및 개선되고 향상되는 개념이다.

### 4. 개발 환경의 변화 : Infra 자동화
> 개발 환경, 개발 지원 환경을 자동화하는 것을 모두 통틀어 **인프라 자동화**라고 한다.
* 개발 환경 준비 과정에 개발 환경으로 **클라우드 인프라를 활용하면 쉽고 빠르게 개발 환경 구축이 가능해지며 팀의 개발 속도가 향상된다.**
* 개발 지원 환경을 자동화하는 데에는 **소스코드를 빌드하는 도구와 빌드 동시에 테스트하는 도구, 가상화된 인프라에 배포하는 도구가 필요하다.**

#### InfraStructure as Code
배포 환경이 MicroService 개수에 따라 급격하게 늘어나며, **효율적으로 관리하기 위한 Infra 구성 및 애플리케이션 빌드 및 배포 등의 자동화를 코드로 처리하는 방식**

### 5. 저장소의 변화: 통합 저장소 -> 분권 데이터 관리
> MicroService - Polyglot store 접근법 -> `Service 별 DB 사용`
* 저장소는 각 서비스 별로 분리돼 있고, **다른 서비스의 저장소를 직접 호출할 수 없고 오로지 API를 통해서만 접근**해야 한다.
* 비즈니스 처리를 위해 **일부 데이터의 복제와 중복 허용이 필요**하며 그렇게 되면 각 저장소에 담긴 `데이터 일관성 문제` 가 발생

#### 데이터 일관성 문제 해결법
1. two-phase commit
   * 여러 노드에 거쳐서 Atomic Transaction Commit을 달성하기 위한 알고리즘
   * 분산 DB Transaction 처리를 위해서 사용하는 고전적인 방법
   * 애플리케이션이 정상적으로 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 것으로부터 시작된다.
   * commit할 준비가 되면 트랜잭션 관리자는 1단계를 시작한다
    * 그 다음, 각 노드에 준비 요청을 보내서 commit 가능 여부를 묻게 되며, 참가자의 응답에 따라서 commit을 할지, rollback을 할지 결정한다.
   * 모든 노드가 “예” 라고 대답하여, commit할 준비가 되었다고 하면, TransactionManager는 2단계에서 커밋 요청을 전송하고 커밋이 실제로 수행된다.
   * 참가자가 “아니오"라고 대답하면 코디네이터는 2단계의 모든 노드에 중단 요청을 보낸다.
   * **문제점**
    * 다른 서비스를 하나의 트랜잭션으로 묶다 보면 각 서비스의 독립성이 침해되며, NoSQL 저장소처럼 2단계 commit을 지원하지 않는 경우가 있다.
    * MicroService는 **데이터 일관성 문제 해결하기 위해** 각 Service를 단일 Transaction으로 묶는 방법 보단 비동기 event 처리를 통한 협업을 강조한다.
2. **비동기 event 처리** - 결과적 일관성(Eventual Consistency)
   * 두 서비스의 데이터가 일시적으로 불일치하는 시점에 있으며, 과정 중에 데이터 간 일관성이 부재한 상태가 존재하지만 결과적으로 두 데이터가 같아진다는 개념
   * 여러 Transaction을 하나로 묶지 않고 별도의 Local Transaction을 각각 수행하며, 일관성이 달라진 부분은 체크해서 보상 Transaction으로 일관성을 맞추는 개념

#### Transaction을 분리하고 Queue를 이용해 보상 Transaction을 활용하는 방법
##### ex) 주문 & 배송 Service
1. `주문 Service`에서 주문 처리 Transaction 수행
   * 동시에 주문 event 발행
   * 주문 event를 Message Queue로 전송
   * `배송 Service`가 주문 event 인식
2. `배송 Service`가 주문 처리에 맞는 배송 처리 Transaction 수행
3. 배송 처리 Transaction 중 오류로 Transaction 실패
   * 배송 처리 실패 event 발행
   * 배송 처리 실패 event가 메시지 큐로 전송
   * `주문 Service`가 배송 처리 실패 이벤트 인식
4. `주문 Service`는 주문 취소(보상 Transaction)을 수행

### 6. 위기 대응 방식의 변화: 실패를 고려한 설계

#### `내결함성(fault toleerance)`
* 시스템은 언제든 실패할 수 있으며, 실패로 인해 더 이상 진행할 수 없더라도 자연스럽게 대응할 수 있도록 설계해야 한다.

#### 기존 시스템
* 무결함 및 실패 무결성 추구
* 시스템이 다운되지 않고 중단되지 않기 위해 **완벽을 추구**

> `실패하지 않는 시스템보다 실패에 빠른 대응할 수 있는 시스템이 쉽고 더 효율적이다.`

#### 실패에 빠른 대응을 위한 환경
1. 다양한 실패에 대비한 **완벽한 테스트 환경을 마련한다**.
2. 시스템의 실패를 감지하고 대응하기 위해 **실시간 모니터링 체계도 갖춰야 한다**.
3. 서킷 브레이커(circuit breaker) 패턴
   * 회로 차단기처럼 각 서비스를 모니터링하고 있다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절하게 대응하는 것
   * 서비스가 긴급 장애 상황에 빠르고 유연하고 탄력적으로 대응할 수 있게 한다.

#### MSA를 지향하기 위한 클라우드 환경에서 비즈니스 민첩성 강화하기 위한 3가지 요소
1. 기술 측면
   * 자동화된 개발 환경 기반의 MSA
2. 업무 방식 측면
   * 점진 반복적인 개발 process
3. 조직 문화 측면
   * 자율적인 업무 기능 중심 팀 및 개발 문화
